/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.umranium.longmark.ui;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;

/**
 *
 * @author umran
 */
public class MultiColumnText extends javax.swing.JPanel {

    public static final String PROP_TEXT = "text";
    
    private int columns, rows;
    private String text = "";
    private List<MyTextArea> textAreas = new ArrayList<MyTextArea>();

    public MultiColumnText() {
        this(40, 10);
    }
    
    /**
     * Creates new form MultiColumnText
     */
    public MultiColumnText(int columns, int rows) {
        this.columns = columns;
        this.rows = rows;
        initComponents();
        
        updateTextAreas();
    }
    
    /**
     * Get the value of text
     *
     * @return the value of text
     */
    public String getText() {
        return text;
    }

    /**
     * Set the value of text
     *
     * @param text new value of text
     */
    public void setText(String text) {
        if (text==null) {
            text = "";
        }
        String oldText = this.text;
        this.text = text;
        updateTextAreas();
        firePropertyChange(PROP_TEXT, oldText, text);
    }

    @Override
    public void setFont(Font font) {
        super.setFont(font);
        if (textAreas!=null) {
            for (MyTextArea txt:textAreas) {
                txt.setFont(font);
            }
        }
    }
    
    private MyTextArea createAddNewTextArea() {
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = textAreas.size();
        gbc.insets = new Insets(0, 2, 0, 2);
        
        MyTextArea textArea = new MyTextArea();
        textArea.setRows(rows);
        textArea.setColumns(columns);
        textArea.setCustomSize(textArea.getTextSize());
//        textArea.addMouseListener(new MouseAdapter() {
//
//            @Override
//            public void mouseClicked(MouseEvent e) {
//                
//            }
//            
//        });
        
        textAreas.add(textArea);
        containerPanel.add(textArea, gbc);
        return textArea;
    }
    
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        containerScrollPanel = new MyScrollPane();
        containerPanel = new javax.swing.JPanel();

        setFont(new java.awt.Font("Arial", 0, 12)); // NOI18N
        setLayout(new java.awt.BorderLayout());

        containerScrollPanel.setWheelScrollingEnabled(false);

        containerPanel.setFocusable(false);
        containerPanel.setLayout(new java.awt.GridBagLayout());
        containerScrollPanel.setViewportView(containerPanel);

        add(containerScrollPanel, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel containerPanel;
    private javax.swing.JScrollPane containerScrollPanel;
    // End of variables declaration//GEN-END:variables


    private void updateTextAreas() {
        int startIndex = 0;
        int totalLen= text.length();
        int lengthLeft = totalLen;
        int currentTextArea = 0;
        
        while (lengthLeft>0) {
            MyTextArea textArea;
            if (currentTextArea<textAreas.size()) {
                textArea = textAreas.get(currentTextArea);
            } else {
                textArea = createAddNewTextArea();
            }
            
            int prefHeight = textArea.getPreferredSize().height;
            //  find approx location
            int currentLen = getNextSegmentLength(text, rows, '\n', startIndex);
            //  adjust location
            setTextAreaText(textArea, startIndex, currentLen);
            //  first fill, if not full
            while (startIndex+currentLen<totalLen &&
                    textArea.getTextSize().getHeight()==prefHeight) {
                //System.out.println(">> "+textArea.getTextSize().getHeight()+">"+prefHeight);
                ++currentLen;
                setTextAreaText(textArea, startIndex, currentLen);
            }
            //  then empty, if overflowing
            while (textArea.getTextSize().getHeight()>prefHeight) {
                //System.out.println(">> "+textArea.getTextSize().getHeight()+">"+prefHeight);
                --currentLen;
                setTextAreaText(textArea, startIndex, currentLen);
            }
            
            //System.out.println(">> "+textArea.getText());
            
            ++currentTextArea;
            startIndex += currentLen;
            lengthLeft -= currentLen;
        }
        
        while (currentTextArea<textAreas.size()) {
            MyTextArea textArea = textAreas.remove(textAreas.size()-1);
            containerPanel.remove(textArea);
        }
    }
    
    private void setTextAreaText(MyTextArea textArea, int start, int len) {
        if (text.charAt(start+len-1)=='\n') {
            --len;
        }
        textArea.setText(text.substring(start, start+len));
    }
    
    private int getNextSegmentLength(String str, int maxCount, char ch, int start) {
        //  find N ch characters after start
        int lastFound = -1;
        int currentStart = start;
        while (maxCount>0) {
            int index = str.indexOf(ch, currentStart);
            if (index>=0) {
                lastFound = index;
                currentStart = index+1;
                --maxCount;
            } else {
                break;
            }
        }
        if (lastFound<0) {
            return str.length() - start;
        }
        return lastFound - start + 1;
    }
    
    private class MyTextArea extends JTextArea {

        public MyTextArea() {
            this.setEditable(false);
            this.setFocusable(false);
            this.setLineWrap(true);
            this.setWrapStyleWord(true);
            this.setFont(MultiColumnText.this.getFont());
        }
        
        private Dimension customSize;

        public Dimension getCustomSize() {
            return customSize;
        }

        public void setCustomSize(Dimension customSize) {
            this.customSize = customSize;
        }
        
        public int getTextHeight() {
            return this.getFontMetrics(this.getFont()).getHeight()*this.getLineCount();
        }
        
        public Dimension getTextSize() {
            return super.getPreferredSize();
        }        

        @Override
        public Dimension getPreferredSize() {
            if (customSize!=null) {
                return customSize;
            }
            return super.getPreferredSize();
        }
    }
    
    private class MyScrollPane extends JScrollPane {

        public MyScrollPane() {
            this.setWheelScrollingEnabled(false);
        }

        @Override
        public synchronized void addMouseWheelListener(MouseWheelListener l) {
            //super.addMouseWheelListener(l); //To change body of generated methods, choose Tools | Templates.
        }
        
        

        
    }
    
}
